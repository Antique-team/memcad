/* Generated by Frama-C */
typedef unsigned long size_t;
typedef unsigned long ulong;
typedef struct _gdsl_node {
  struct _gdsl_node *succ ;
  struct _gdsl_node *pred ;
} _gdsl_node;
typedef _gdsl_node *_gdsl_node_t;
typedef struct _gdsl_list {
  _gdsl_node_t d ;
  _gdsl_node_t z ;
} _gdsl_list;
typedef _gdsl_list *gdsl_list_t;
/*@ assigns \result;
  assigns \result \from __size; */
/* extern  __attribute__((__nothrow__)) void *malloc(size_t __size) __attribute__(( */
/* __malloc__, __leaf__)); */
/*@ assigns \nothing; */
/* extern  __attribute__((__nothrow__)) void free(void) __attribute__((__leaf__)); */

extern _gdsl_node_t _gdsl_node_alloc(void);

extern void _gdsl_node_free(void);

extern _gdsl_node_t _gdsl_node_get_pred(_gdsl_node_t const n);

extern void _gdsl_node_set_succ(_gdsl_node_t n, _gdsl_node_t const succ);

extern void _gdsl_node_set_pred(_gdsl_node_t n, _gdsl_node_t const pred);

extern void _gdsl_node_link(_gdsl_node_t node1, _gdsl_node_t node2);

extern _gdsl_node_t _gdsl_node_alloc(void)
{
  _gdsl_node_t __retres;
  _gdsl_node_t n;
  n = (_gdsl_node_t)malloc((unsigned long)sizeof(_gdsl_node));
  if (n == 0) {
    __retres = (_gdsl_node *)((void *)0);
  } else {
    n->succ = (_gdsl_node *)((void *)0);
    n->pred = (_gdsl_node *)((void *)0);
    __retres = n;
  }
  return __retres;
}

extern void _gdsl_node_free(void)
{
  return;
}

extern _gdsl_node_t _gdsl_node_get_pred(_gdsl_node_t const n)
{
  _gdsl_node_t __retres;
  __retres = n->pred;
  return __retres;
}

extern void _gdsl_node_set_succ(_gdsl_node_t n, _gdsl_node_t const succ)
{
  n->succ = succ;
  return;
}

extern void _gdsl_node_set_pred(_gdsl_node_t n, _gdsl_node_t const pred)
{
  n->pred = pred;
  return;
}

extern void _gdsl_node_link(_gdsl_node_t node1, _gdsl_node_t node2)
{
  node1->succ = node2;
  node2->pred = node1;
  return;
}

extern gdsl_list_t gdsl_list_alloc(void);

extern void gdsl_list_insert_tail(gdsl_list_t list);

extern gdsl_list_t gdsl_list_alloc(void)
{
  gdsl_list_t __retres;
  gdsl_list_t list;
  list = (gdsl_list_t)malloc((unsigned long)sizeof(_gdsl_list));
  if (list == 0) {
    __retres = (_gdsl_list *)((void *)0);
  } else {
    list->d = _gdsl_node_alloc();
    if (list->d == 0) {
      __retres = (_gdsl_list *)((void *)0);
    } else {
      list->z = _gdsl_node_alloc();
      if (list->z == 0) {
        _gdsl_node_free();
        __retres = (_gdsl_list *)((void *)0);
      } else {
        _gdsl_node_link(list->d,list->z);
        _gdsl_node_set_succ(list->z,list->z);
        _gdsl_node_set_pred(list->d,list->d);
        __retres = list;
      }
    }
  }
  return __retres;
}

extern void gdsl_list_insert_tail(gdsl_list_t list)
{
  _gdsl_node_t tail;
  _gdsl_node_t tmp;
  tail = _gdsl_node_alloc();
  if (tail != (void *)0) {
    {
      /*sequence*/
      tmp = _gdsl_node_get_pred(list->z);
    }
    _gdsl_node_link(tmp,tail);
    _gdsl_node_link(tail,list->z);
  }
  return;
}

void main(void)
{
  gdsl_list_t l1;
  l1 = gdsl_list_alloc();
  _memcad( "output_dot( )" );
  assert(l1->d->pred == l1->d); /* GDSL_list invariant 1 */
  assert(l1->z->succ == l1->z); /* GDSL_list invariant 2 */
  assert(l1->d->succ == l1->z);
  assert(l1->z->pred == l1->d);
  _memcad( "check_inductive( l1->d->succ, gdsl_node, [ l1->d, l1->z | | ] )" );
  gdsl_list_insert_tail(l1);
  _memcad( "output_dot( l1, stdout )" ); /* graph with only l1 and stdout shown */
  assert(l1->d->pred == l1->d); /* GDSL_list invariant 1 */
  assert(l1->z->succ == l1->z); /* GDSL_list invariant 2 */
  assert(l1->d->succ != l1->z);
  assert(l1->d->succ == l1->z->pred);
  /* FBR: this last one fails */
  _memcad( "check_inductive( l1->d->succ, gdsl_node, [ l1->d, l1->z | | ] )" );
  return;
}
